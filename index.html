<!DOCTYPE html>
<html>
  <head>
    <title>Roboterarm</title>
    <style>
      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>

  <body>
    <p>Um das Modell zu Laden, klicken sie "Bewegen". <br> 
      Wenn sie einen Punkt einstellen möchten, zu dem sich der arm bewegen soll, stellen sie diesen auf dem entsprechenden Slider ein. <br>
       Dieser kontrolliert die verscheidenen Kordinaten des Punktes, zu welchem bei erneutem Drücken der Arm bewegt wird.<br>
       Genauere Infos über Funktionsweise u.ä. finden sie <a href="https://github.com/Selixxx/Robotterarm/blob/main/README.md">hier</a></p>
    <div>
      <button type="button" style="width:120px;height:60px;" onclick="test()">
        Bewegen
      </button>
    </div>
    <script src="./js/three.js"></script>
    <script type="text/javascript" src="./lib/dat.gui.min.js"></script>
    <script type="text/javascript" src="./js/GLTFLoader.js"></script>
    <script src="./js/OrbitControls.js"></script>
    <script>
      const NEUNZIG_GRAD = Math.PI / 2
      const arm_length = 35
      var renderer = new THREE.WebGLRenderer()
      renderer.setClearColor(0xaaaaaa)
      renderer.setSize(window.innerWidth, window.innerHeight)
      document.body.appendChild(renderer.domElement)

      var scene = new THREE.Scene()
      const gui = new dat.GUI()
      // const loader = new GLTFLoader();

      var camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        1,
        10000,
      )
      camera.position.x = 0
      camera.position.z = 80
      camera.position.y = 15

      // LIGHTS   //das ist ein kommentar
      ambientLight = new THREE.AmbientLight(0xffffff, 0.5)
      scene.add(ambientLight)
      light = new THREE.PointLight(0xffffff, 0.8, 100)
      light.position.set(0, 10, 20)
      light.castShadow = true
      // Will not light anything closer than 0.1 units or further than 25 units
      light.shadow.camera.near = 0.1
      light.shadow.camera.far = 25
      scene.add(light)

      function addBasicCube(pos) {
        var geometry = new THREE.SphereGeometry(4, 12, 12)
        //geometry.translate(7 / 2, 3.5, 3.5)
        var material = new THREE.MeshPhongMaterial({
          color: 0x89cff0,
        })
        var cube = new THREE.Mesh(geometry, material)
        cube.receiveShadow = true
        cube.castShadow = true
        cube.position = pos
        cube.name = 'cube'
        scene.add(cube)
        cube.position.x = pos.x
        cube.position.y = pos.y
        cube.position.z = pos.z
        gui.add(cube.position, 'x', -50, 75)
        gui.add(cube.position, 'y', 0, 50)
        gui.add(cube.position, 'z', -50, 50)
      }

      function degToRad(angle) {
        return (angle * Math.PI) / 180
      }

      function radToDeg(angle) {
        return (angle / Math.PI) * 180
      }

      async function addArmsWithPivots(pos, lenght_arms, scale_y, scale_z) {
        //add arm
        // var armModel = await loadModel()

        //var ArmModel = scene.getObjectByName("ArmModel")

        var geometry = new THREE.BoxGeometry(lenght_arms, scale_y, scale_z)
        geometry.translate(0, 0, 0)
        var material = new THREE.MeshPhongMaterial({ color: 0x0000ff })
        var cube = new THREE.Mesh(geometry, material)
        cube.receiveShadow = true
        cube.castShadow = true
        cube.position.x = pos.x
        cube.position.y = pos.y
        cube.position.z = pos.z
        cube.name = 'arm2'

        scene.add(cube)

        //var cube = scene.getObjectByName('ArmModel')

        //
        // ZWEITER CUBE
        //

        var geometry_blob = new THREE.BoxGeometry(lenght_arms, scale_y, scale_z)
        geometry.translate(lenght_arms / 2, 0, 0)
        var material_blob = new THREE.MeshPhongMaterial({ color: 0xff69b4 })
        var cube_blob = new THREE.Mesh(geometry, material_blob)
        cube_blob.receiveShadow = true
        cube_blob.castShadow = true
        cube_blob.position.x = pos.x
        cube_blob.position.y = pos.y
        cube_blob.position.z = pos.z
        cube_blob.name = 'arm1'

        scene.add(cube_blob)

        cube_blob.position.x = -lenght_arms

        //kleiner debug teil
        //var kleineDebugVariable = getObjectByName('arm1')

        //arm1.add(cube)

        cube_blob.add(cube)

        cube_blob.position.x = cube_blob.position.x + lenght_arms

        cube.position.x = lenght_arms
        cube.position.z = 0
        cube.position.y = 0

        var plate_geometry = new THREE.BoxGeometry(20, 1, 20)
        plate_geometry.translate(0, 0, 0)
        var plate_material = new THREE.MeshPhongMaterial({ color: 0xff0000 })
        var plate = new THREE.Mesh(plate_geometry, plate_material)
        plate.receiveShadow = true
        plate.castShadow = true
        plate.position.x = 0
        plate.position.y = 0
        plate.position.z = 0
        plate.name = 'groundPlate'

        scene.add(plate)

        //plate.rotation.y = -NEUNZIG_GRAD;

        plate.add(cube_blob)
      }
      // addArmsWithPivots(new THREE.Vector3(0, 0, 0), lenght_arms, 5, 5)
      //moveArmsToPoint(new THREE.Vector3(10, 10, 10))

      function moveArmsToPoint(to) {
        /***********************
        alpha rotation = rotation.y armBottom && armTop
        pos gelenk =

        ***********************/
        const from = new THREE.Vector3(0, 0, 0)
        var EF = Math.abs(to.z - from.z)
        var MF = Math.abs(to.x - from.x)
        var ME = Math.sqrt(MF ** 2 + EF ** 2)

        /*var arm2 = scene.getObjectByName('ArmModelTop')
        var arm1 = scene.getObjectByName('ArmModelBottom')
        var groundPlate = scene.getObjectByName('groundPlate')*/
        var arm1 = scene.getObjectByName('arm1')
        var arm2 = scene.getObjectByName('arm2')
        var groundPlate = scene.getObjectByName('groundPlate')

        var EF = rotateArm(from, to, EF)
        var alpha_rotation = rotateArm(from, to, alpha)

        groundPlate.rotation.y = alpha_rotation

        var PQ = to.y - from.y
        var SQ = to.x - from.x
        var SP = Math.sqrt(PQ * PQ + ME * ME)
        //var SP = Math.sqrt(lenght_arms ** 2 + lenght_arms ** 2);
        var alpha1 = Math.asin(PQ / SP)
        var alpha2 = Math.acos(SP ** 2 / (2 * SP * arm_length))
        var alpha = alpha1 + alpha2
        var beta = Math.acos(
          (arm_length ** 2 + arm_length ** 2 - SP ** 2) / (2 * arm_length ** 2),
        )
        console.log('alpha 2 = ' + alpha2)
        console.log('alpha 1 = ' + alpha1)
        console.log('degree beta = ' + radToDeg(beta))
        console.log('alpha = ' + alpha)
        console.log('degree alpha = ' + radToDeg(alpha))
        console.log('PQ = ' + PQ)
        console.log('SP = ' + SP)

        arm1.rotation.z = alpha
        arm2.rotation.z = -2 * NEUNZIG_GRAD + beta
        position = new THREE.Vector3(0, 0, 0)
        calculateJoint(position, alpha)
      }

      async function loadModel() {
        const loader = new GLTFLoader()
        var arm2 = loader.load('./arm_top2.gltf', function (gltf) {
          const armGeometry = gltf.scene.children.find(
            (child) => child.name === 'Sphere',
          ).geometry
          const ArmMaterial = new THREE.MeshPhongMaterial({
            color: 0x9900ff,
          })
          var armMesh = new THREE.Mesh(armGeometry, ArmMaterial)
          armMesh.name = 'ArmModel'

          armMesh.position.y = 10
          armMesh.position.x = 0
          armMesh.position.z = 0
          armMesh.scale.x = 3
          armMesh.scale.y = 3
          armMesh.scale.z = 3
          return armMesh
          console.log(armMesh)
        })

        return await arm2
      }

      function createArm(length, color) {
        var arm = new THREE.BoxGeometry(length, 3, 3)
        arm.translate(length / 2, 0, 0)
        var material = new THREE.MeshPhongMaterial({ color: color })
        return new THREE.Mesh(arm, material)
      }
      function drawTestArm(to) {
        console.log("to: x="+to.x+",y="+to.y+", z="+to.z)
        var l_bas = Math.sqrt(to.x ** 2 + to.y ** 2 + to.z ** 2)
        var rot_y = Math.acos(Math.abs(to.x / Math.sqrt(to.x ** 2 + to.y ** 2)))
        if (to.x <= 0 && to.y >= 0) {
          rot_y = rot_y + 2 * NEUNZIG_GRAD
          console.log('-+')
        } else if (to.x <= 0 && to.y <= 0) {
          rot_y = 2 * NEUNZIG_GRAD - rot_y
          console.log('--')
        }  else if (to.x >= 0 && to.y <= 0) {
          rot_y = -rot_y
          console.log('+-')
        }
          else if(to.x > 0 && to.y > 0){
            rot_y = -rot_y
            console.log("++")
          }

        var rot_z = Math.acos(
          Math.abs(Math.sqrt(to.x ** 2 + to.y ** 2)) / l_bas,
        )
        console.log('rot_y:' + radToDeg(rot_y) + ', rot_z:' + radToDeg(rot_z))

        // var adjustedAngles = adjustAngles(new THREE.Vector3(0, 0, 0), to, rot_y, rot_z)
        // rot_y = adjustedAngles.rot_y
        // rot_z = adjustedAngles.rot_z
        // console.log(adjustedAngles)
        var green_element = createArm(l_bas, 0x00ff00)
        //scene.add(green_element)
        green_element.position.x = 0
        green_element.position.y = 0
        green_element.position.z = 0

        green_element.rotation.y = rot_y
        green_element.rotation.z = rot_z

        //adding the 2 arms
        var joint = new THREE.Vector3(0, 0, 0)
        rot_a = Math.acos(l_bas / 2 / arm_length)
        joint.y = Math.sin(rot_a + rot_z) * arm_length
        var zwerg = Math.cos(rot_a + rot_z) * arm_length
        joint.x = zwerg * Math.cos(rot_y)
        joint.z = -zwerg * Math.sin(rot_y)

        var red_element = scene.getObjectByName('ArmModelBottom')//createArm(arm_length, 0xff0000) //
        scene.add(red_element)
        red_element.position.x = 0
        red_element.position.y = 0

        red_element.rotation.z = rot_z + rot_a - NEUNZIG_GRAD
        red_element.rotation.y = rot_y

        var blue_element = scene.getObjectByName('ArmModelTop') //createArm(arm_length, 0x0000ff)//
        scene.add(blue_element)

        blue_element.position.x = joint.x
        blue_element.position.y = joint.y
        blue_element.position.z = joint.z

        blue_element.rotation.z = rot_z - rot_a - NEUNZIG_GRAD
        blue_element.rotation.y = rot_y
        console.log(blue_element.position)
        console.log(joint)
      }

      function test() {
        //  var armTop = scene.getObjectByName('ArmModelTop')
        //armTop.position.x = 0
        //armTop.rotation.y = NEUNZIG_GRAD
        //drawTestArm(new THREE.Vector3(0, 20, -10))
        bewegen()
      }

      /*function buildArmModels() {
        const geometryArmBottom = new THREE.CylinderGeometry(3, 3, 35, 32)
        geometryArmBottom.translate(0,35/2,0)
        const materialArmBottom = new THREE.MeshPhongMaterial({ color: 0xffff00 })
        const armBottom = new THREE.Mesh(geometryArmBottom, materialArmBottom)
        
        armBottom.name = 'ArmModelBottom'
        scene.add(armBottom)

        var plate_geometry = new THREE.BoxGeometry(20, 1, 20)
              plate_geometry.translate(0, 0, 0)
              var plate_material = new THREE.MeshPhongMaterial({
                color: 0xff0000,
              })
              var plateMesh = new THREE.Mesh(plate_geometry, plate_material)
              plateMesh.receiveShadow = true
              plateMesh.castShadow = true
              plateMesh.position.x = 0
              plateMesh.position.y = 0
              plateMesh.position.z = 0
              plateMesh.name = 'groundPlate'
              scene.add(plateMesh)
      }
      buildArmModels()*/
      

      function addCoordianteSystem() {
        var x_Arm = createArm(10, 0)
        scene.add(x_Arm)
        x_Arm.position.x = 0
        x_Arm.position.y = 0
        x_Arm.position.z = 0

        x_Arm = createArm(10, 0)
        scene.add(x_Arm)
        x_Arm.position.x = 0
        x_Arm.position.y = 0
        x_Arm.position.z = 0
        x_Arm.rotation.y = NEUNZIG_GRAD
        x_Arm = createArm(10, 0)
        scene.add(x_Arm)
        x_Arm.position.x = 0
        x_Arm.position.y = 0
        x_Arm.position.z = 0
        x_Arm.rotation.z = NEUNZIG_GRAD
      }

      function adjustAngles(from, to, rot_y, rot_z) {
        console.log('253: ' + radToDeg(rot_y) + ', ' + radToDeg(rot_z))

        if (to.x <= from.x && to.z <= from.z) {
          rot_y = 2 * NEUNZIG_GRAD - rot_y
        }
        console.log('258: ' + radToDeg(rot_y) + ', ' + radToDeg(rot_z))

        if (to.x <= from.x && to.z >= from.z) {
          rot_y = rot_y + 2 * NEUNZIG_GRAD
        }
        console.log('264: ' + radToDeg(rot_y) + ', ' + radToDeg(rot_z))

        if (to.x >= from.x && to.z >= from.z) {
          rot_y = 4 * NEUNZIG_GRAD - rot_y
        }
        console.log('269: ' + radToDeg(rot_y) + ', ' + radToDeg(rot_z))

        return { rot_y: rot_y, rot_z: rot_z }
      }

      function rotateArm(from, to) {
        var EF = Math.abs(to.z - from.z)
        var MF = Math.abs(to.x - from.x)
        var ME = Math.sqrt(MF ** 2 + EF ** 2)
        var alpha = Math.asin(EF / ME)

        if (to.x >= from.x && to.z <= from.z) {
          console.log('currently rotating to z-, x+')
        }

        if (to.x <= from.x && to.z <= from.z) {
          alpha = 2 * NEUNZIG_GRAD - alpha
        }

        if (to.x <= from.x && to.z >= from.z) {
          alpha = alpha + 2 * NEUNZIG_GRAD
        }

        if (to.x >= from.x && to.z >= from.z) {
          alpha = 4 * NEUNZIG_GRAD - alpha
        }

        console.log('MF beim rotieren ist = ' + MF)
        console.log('ME beim rotieren ist = ' + ME)
        console.log('EF beim rotieren ist = ' + EF)
        console.log('alpha beim rotieren ist = ' + alpha)
        //console.log('beta beim rotieren ist = ' + beta)
        return alpha
      }

      function calculateJoint(to, alpha) {
        var jointPosition = new THREE.Vector3(0, 0, 0)
        var BC = Math.sin(alpha) * arm_length
        jointPosition.y = BC
        var AC = Math.cos(alpha) * arm_length
        console.log('AC = ' + AC)
        var DC = Math.sin(alpha) * arm_length
        console.log('DC = ' + DC)
        var AD = Math.sqrt(arm_length ** 2 - BC ** 2)
        console.log('AD = ' + AD)

        if (to.x <= 0 && to.z >= 0) {
          DC = -DC
        }
        if (to.x >= 0 && to.z <= 0) {
          AD = -AD
        }
        if (to.x <= 0 && to.z <= 0) {
          AD = -AD
          DC = -DC
        }
        if (to.x > 0 && to.z > 0) {
        }
        jointPosition.x = AD
        jointPosition.z = AC
        addBasicCube(jointPosition)
      }

      function bewegen() {
        var cube = scene.getObjectByName('MoveToObject')
        var posCube = new THREE.Vector3(
          cube.position.x,
          cube.position.z,
          cube.position.y,
        )
        drawTestArm(posCube)
      }
      

      function init() {
        const loader = new GLTFLoader()
        //         loader.load('./arm_top2.gltf', function (gltf) {
        loader.load('./test_arm1.gltf', (gltf) => {
          const armGeometry = gltf.scene.children.find(
            (child) => child.name === 'Cube',
          ).geometry
          armGeometry.translate(-1,0,0)
          const ArmMaterial = new THREE.MeshPhongMaterial({
            color: 0x9900ff,
          })
          var armMeshArmTop = new THREE.Mesh(armGeometry, ArmMaterial)
          armMeshArmTop.name = 'ArmModelTop'

          armMeshArmTop.position.x = 0
          armMeshArmTop.position.y = 0
          armMeshArmTop.position.z = 0
          armMeshArmTop.scale.x = .5
          armMeshArmTop.scale.y = .5
          armMeshArmTop.scale.z = .6
          //scene.add(armMeshArmTop)
          /*
            fängt an den zweiten Arm zu laden
            */
          loader.load('./test_arm2.gltf', (gltf) => {
            const armGeometry = gltf.scene.children.find(
              (child) => child.name === 'Cube',
            ).geometry
            armGeometry.translate(0, 0, 0)
            const ArmMaterial = new THREE.MeshPhongMaterial({
              color: 0x0099ff,
            })
            var armMeshArmBottom = new THREE.Mesh(armGeometry, ArmMaterial)
            
            armMeshArmBottom.name = 'ArmModelBottom'
            armMeshArmBottom.position.x = 0
            armMeshArmBottom.position.y = 0
            armMeshArmBottom.position.z = 0
            armMeshArmBottom.rotation.x = 0
            armMeshArmBottom.rotation.y = -NEUNZIG_GRAD
            armMeshArmBottom.rotation.z = 0
            armMeshArmBottom.scale.x = 2.25
            armMeshArmBottom.scale.y = 2.25
            armMeshArmBottom.scale.z = 2.25

            //scene.add(armMeshArmBottom)
            /*
            fängt an den cube zu laden
            */
            loader.load('./moveToObject.gltf', (gltf) => {
              const armGeometry = gltf.scene.children.find(
                (child) => child.name === 'Cube',
              ).geometry
              const ArmMaterial = new THREE.MeshPhongMaterial({
                color: 0xff99ff,
              })
              var armMeshMoveToObject = new THREE.Mesh(armGeometry, ArmMaterial)
              armMeshMoveToObject.name = 'MoveToObject'
              //scene.add(armMeshMoveToObject)
              armMeshMoveToObject.position.x = 25
              armMeshMoveToObject.scale.x = 2
              armMeshMoveToObject.scale.y = 2
              armMeshMoveToObject.scale.z = 2
              scene.add(armMeshMoveToObject)
              gui.add(armMeshMoveToObject.position, "x", -50, +50)   
              gui.add(armMeshMoveToObject.position, "y", 0, +50)   
              gui.add(armMeshMoveToObject.position, "z", -50, +50)              

              var plate_geometry = new THREE.BoxGeometry(20, 1, 20)
              plate_geometry.translate(0, 0, 0)
              var plate_material = new THREE.MeshPhongMaterial({
                color: 0xff0000,
              })
              var plateMesh = new THREE.Mesh(plate_geometry, plate_material)
              plateMesh.receiveShadow = true
              plateMesh.castShadow = true
              plateMesh.position.x = 0
              plateMesh.position.y = 0
              plateMesh.position.z = 0
              plateMesh.name = 'groundPlate'

              //scene.add(plateMesh)
              //armMeshArmBottom.add(armMeshArmTop)
              // scene.add(armMeshArmBottom)
              // scene.add(plateMesh)
              scene.add(armMeshArmTop)
              scene.add(armMeshArmBottom)

              // plateMesh.add(armMeshArmBottom)

              scene.add(plateMesh)

              //   console.log(scene.children[2].children[0].children[0])

              //scene.add(plateMesh)

              /*armMeshArmBottom.rotation.x = 0
              armMeshArmBottom.rotation.y = -NEUNZIG_GRAD
              armMeshArmTop.rotation.z = 0
              armMeshArmBottom.rotation.x = NEUNZIG_GRAD / 2
              */
              //plateMesh.rotation.y = NEUNZIG_GRAD / 2
              //armMeshArmBOt.rotation.y = NEUNZIG_GRAD / 2
            })
          })
        })
      }

      init()

      /*


        funktion drehmitwinkel( winkel 1 und winkel 2)

          cube 1 rotation = winkel 1
          cube 2 rotation = winkel 2



      */

      function move_by_angels(winkel_arm1, winkel_arm2, winkel_groundPlate) {
        var arm1 = scene.getObjectByName('arm1')
        var arm2 = scene.getObjectByName('arm2')
        var groundPlate = scene.getObjectByName('groundPlate')

        arm1.rotation.z = degToRad(winkel_arm1)
        arm2.rotation.z = degToRad(-winkel_arm2)
        groundPlate.rotation.y = degToRad(winkel_groundPlate)
      }

      function getObjectByName(name) {
        var arm2 = scene.getObjectByName(name)
      }

      function addArm(pos, lenght) {
        var geometry = new THREE.BoxGeometry(lenght, 5, 5, pos.x, pos.y, pos.z)
        var material = new THREE.MeshPhongMaterial({ color: 0xff0000 })
        var cube = new THREE.Mesh(geometry, material)
        cube.receiveShadow = true
        cube.castShadow = true
        cube.position.x = pos.x
        cube.position.y = pos.y
        cube.position.z = pos.z

        scene.add(cube)
      }

      function rotatePivot(degree, axe, object) {
        var pivot_debug = new THREE.Object3D()
      }
      //(pos, scale_x, scale_y, scale_z)

      function camera_mover_debug() {
        //camera.position.x = camera.position.x + 20
      }

      //camera.rotation.x = -20;
      controls = new THREE.OrbitControls(camera, renderer.domElement)

      function render() {
        requestAnimationFrame(render)
        // Enable Shadows in the Renderer
        renderer.shadowMap.enabled = true
        renderer.shadowMap.type = THREE.BasicShadowMap
        renderer.render(scene, camera)
      }

      // init()

      render()
      camera_mover_debug()
    </script>
  </body>
</html>
